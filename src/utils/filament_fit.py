import matplotlib.pyplot as plt
import numpy as np
import sklearn
import sys
sys.path.append(".")

from sklearn.cluster import DBSCAN
from sklearn import metrics
from sklearn.datasets import make_blobs
from sklearn.preprocessing import StandardScaler
from utils import ransac_fit

#input: a specific file name or an index, the dictionary generated by parse_helix_coordinates
#output: a scatter plot of the specified coordinate file
def visualize_file(name, file_library, index = None):
    img = file_library[name]
    plt.scatter(img[0], img[1], marker=".")

#input: the numpy array tuple (x,y) of a coordinate file, ie: file_library[file_name]
#output: a list of numpy tables, each representing the coordinates of particles who belong in the same cluster/filament
def DBSCAN_fit(img, eps=15, min_samples=5):
    # #############################################################################

    # provide a m * 2 coordinate array for the data points on xy plane
    X = np.concatenate((img[0][..., np.newaxis], img[1][..., np.newaxis]), axis=1)

    # #############################################################################
    # Compute DBSCAN
    db = DBSCAN(eps, min_samples).fit(X)
    # obtain a mask for the useful data points, as defined by "core samples",
    # they contain sufficient number of neighbours within the eps distance
    core_samples_mask = np.zeros_like(db.labels_, dtype=bool)
    core_samples_mask[db.core_sample_indices_] = True

    # obtain the classification labels mapped from each point
    labels = db.labels_

    # Number of clusters in labels, ignoring noise if present.
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    n_noise_ = list(labels).count(-1)

    # #############################################################################
    # Plot result
    import matplotlib.pyplot as plt

    # Black removed and is used for noise instead.
    # create a set of labels
    unique_labels = set(labels)
    # create a corresponding set of colours for bijection to the the set of labels
    colors = [plt.cm.Spectral(each)
              for each in np.linspace(0, 1, len(unique_labels))]

    list_of_clusters = []

    # for each class label and its colour
    for k, col in zip(unique_labels, colors):
        # set the colour to black if the class is assigned to -1 (noise)
        if k == -1:
            # Black used for noise.
            col = [0, 0, 0, 1]

        # obtain a boolean vector to select for coordinates in X of the current k only
        class_member_mask = (labels == k)

        # obtain a list of coordinates from X if they belong to the current k(class) and they are "core samples"
        xy = X[class_member_mask & core_samples_mask]

        # plot the core samples as large dots
        '''plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),
                 markeredgecolor='k', markersize=14)'''

        # plot the non-core samples as smaller dots using a mask for: current k, not "core samples"
        xy_not_core = X[class_member_mask & ~core_samples_mask]
        '''plt.plot(xy_not_core[:, 0], xy_not_core[:, 1], 'o', markerfacecolor=tuple(col),
                 markeredgecolor='k', markersize=6)'''

        cluster = xy
        list_of_clusters.append(cluster)

    '''plt.title('Estimated number of clusters: %d' % n_clusters_)
    plt.close()'''
    return list_of_clusters

def optics_fit(img, xi = -0.15, min_samples=2):
    from sklearn import cluster
    print(img)
    X = np.concatenate((img[0][...,np.newaxis], img[1][...,np.newaxis]), axis = 1)
    print(X)
    optics = cluster.OPTICS(min_samples,
                            cluster_method='xi',
                            xi = xi)

    optics.fit(X)

    if hasattr(optics, 'labels_'):
        y_pred = optics.labels_.astype(int)
    else:
        y_pred = optics.predict(X)

    labels = optics.labels_

    unique_labels = set(labels)

    clusters = []
    for l in unique_labels:
        class_member_mask = (labels == l)
        cluster = X[class_member_mask]
        clusters.append(cluster)
    print(clusters)
    return clusters


#input: output of DBSCAN_fit - a list of numpy arrays, a path for saving the figure
#output: None
def filament_fit(list_of_clusters, save_path):
    for cluster in list_of_clusters:
        poly_o = ransac_fit.polyfit(cluster, 2, 1, disable_linear=True, directory_mode=False)
        arclength_o = ransac_fit.arclength(poly_o)
        x = ransac_fit.spacing(arclength_o, 60.218)
        y = poly_o["model"].predict(x)

        plt.scatter(x, y, color="purple")
    plt.savefig(save_path)
    plt.close()